// Copyright © 2023 Michael Thompson
// SPDX-License-Identifier: GPL-2.0-or-later

// Generates enums_do_not_edit.go in the current directory

//go:build ignore
// +build ignore

package main

import (
        "os"
        "fmt"
        "log"
	"bufio"
	"regexp"
	"strings"
)


const sourceFile = "grammar.go"
const targetFile = "enums_do_not_edit.go"

const heading = `// Copyright © 2023 Michael Thompson
// SPDX-License-Identifier: GPL-2.0-or-later

// Code generated by mk_enums.go.  DO NOT EDIT.

package vectordata

const (
`

func main() {
	objnames := []string{}
	re := regexp.MustCompile(`^\s*"(\w+)",`)
	infile, err := os.Open(sourceFile)
	if err != nil {
		log.Fatal(err)
	}
	scanner := bufio.NewScanner(infile)
	for scanner.Scan() {
		got := re.FindStringSubmatch(scanner.Text())
		if len(got) > 1 {
			objnames = append(objnames, got[1])
		}
	}
	if err := scanner.Err(); err != nil {
		log.Fatal("scanner error: %s", err)
	}
	infile.Close()
	if objnames[0] != "0" {
		log.Fatal("Expected first list name to be 0")
	}

	outfile, err := os.Create(targetFile)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Fprint(outfile, heading)
	suffix := " = iota"
	for _, name := range objnames {
		fmt.Fprintf(outfile, "\tmit%s%s\n", ucFirst(name), suffix)
		suffix = ""
	}
	fmt.Fprint(outfile, ")\n\nvar nameToTypeMap map[string]int = map[string]int{\n")
	for i, name := range objnames {
		if i > 0 {
			fmt.Fprintf(outfile, "\t%-14s mit%s,\n", "\"" + name + "\":", ucFirst(name))
		}
	}
	fmt.Fprint(outfile, "}\n\nvar typeMapToName []string = []string{\n")
	for i, name := range objnames {
		if i == 0 {
			name = "(unknown type)"
		}
		fmt.Fprintf(outfile, "\t\"%s\",\n", name)
	}
	fmt.Fprintf(outfile, "}\n")
	outfile.Close()
}


func ucFirst(str string) string {
	asRunes := []rune(str)
	return strings.ToUpper(string(asRunes[0])) + string(asRunes[1:])
}

