// Copyright © 2023 Michael Thompson
// SPDX-License-Identifier: GPL-2.0-or-later

Misiones User Manual
=====================
Michael Thompson <32822313+potano@users.noreply.github.com>
:doctype: book
:linkcss!:
:sectnums!:
:sectnumlevels: 0

[preface]
== Introduction

Misiones reads a set of data about historical features and roads to generate a Javascript
data file to populate an interactive map powered by the LeafletJS Javascript library.
The source data set is taken from multiple files that describe various map features and
their locations.  Most features may have styling applied to them not only via explicit
style names but also as modified according to how well attested they are by historical
and modern references.

Map features include those as provided by the LeafletJS library—points, rectangles,
polygons, circles, paths, and markers—but also aggregates of items: features, segments,
and routes.  Most of these may have optional attributes attached to them:  styles,
attestation indicators, and on-click popups.

All these features are to be contained in one or more _layers_, which are aggregations
of features which may be selected or deselected for display on the map via a small
selection box that LeafletJS draws on the map.

== Source files
Source files consist of S-expressions, a form borrowed from the Lisp programming
language to represent the basic structural concept of that language, a _list_.
S-expressions have a very simple syntax that makes it easy to let lists contain other
lists.  This example of a map feature containing marker and a nearly rectangular
polygon illustrates several of the basic structural forms:

----
(feature
    (marker  30.2532 -83.1235)
    (polygon
         30.2533 -83.1236     30.2531 -83.1236
         30.2533 -83.1234     30.2531 -83.1234
    )
)
----

An S-expression consists of an opening parenthesis followed immediately by a headword
(here _feature_, _marker_, and _polygon_) and then some contents followed by a
matching closing parenthesis.  The _feature_ object here contains a marker, and the
_marker_ contains a latitude/longitude pair.  The _polygon_ contains four
latitude/longitude pairs.  Whitespace separates the tokens but is optional when the
lexical rules of the tokens make the separation unambiguous (as between the marker's
longitude and the closing parenthesis).  As with Lisp, *misiones* uses the bare
minimum of punctuation in its syntax.

Many of the list types in *misiones* may be marked by an identifier so that they may
be referred to at other places in the data set.  The main reason for doing this is
to allow the user to avoid deep nesting of lists in a single source file and to
spread the data set across multiple source files.  It also allows the sharing of parts
of the data by multiple layers or routes.

A list name is stated as an identifier that follows a list headword.  This
example illustrates a path with an identifier:

----
(path CentralFloridaRailroadFanlew
    30.272119 -84.052327
    30.273955 -84.052246
    30.274067 -84.052225
    30.274182 -84.052209
)
----

Using the identifier _CentralFloridaRailroadFanlew_, another map feature may include
the path by reference.

Identifiers are optional for lists contained in other lists but are required for lists
at the top level except for the _levels_ list, the root of the tree.  The program
detects and forbids cycles in the map data.


=== Lexical rules

Lists, as noted above, are indicated by S-expressions which contain some number of
items.  S-expressions begin with an opening parenthesis followed immediately by a
headword.  Following the headword come some number of scalar tokens and/or
S-expressesions ended by a closing parenthesis.  Scalar token types are identified
by their starting characters and are considered to end at the first character not
allowed for that type.  This fact allows the lexical analyzer separate tokens in the
input stream without relying on whitespace to separate them, but for considerations of
readability users are discouraged from overuse of this mechanism.

Lexical items representing scalar values:

string:: The sequence of characters between two double-quote marks.  The string
between the quote marks may contain backslash-escape sequences to insert special
characters or to escape a double-quote mark or a backslash.

integer:: A sequence of one or more digits optionally preceded by a plus or minus sign.

float:: Like an integer, but also contains a decimal point.

identifier:: A sequence beginning with a letter or underscore followed by any number
of letters, digits, or underscores.  Such an sequence may also contain a dot followed
by a sequence of characters as described in the first sentence.

hex literal:: A # character followed by 2 or more hexadecimal digits.  The resulting
value is treated as a string.

base-64 literal:: A | character followed by a sequence of base-64 characters.  The
resulting value is treated as a string.

comment:: A semicolon character followed by all characters up to the end of the line.
Is treated like whitespace.


=== List Types

There are several types of lists that *misiones* recognizes.  These fall into five
categories:  collections, geometric features, attributes, configuration, and lists of
references to collections and geometric features.  Items of the first two categories
may appear at the outer level in a source file (viz. not contained in some other
list) whereas the others must appear within other lists.  Only those lists which may
appear at the outer level may have names, so this documentation describes such lists
as "nameable".  All such list names share the same namespace.

Here are the categories and a summary of the list types which belong to the
categories:

collections:: Groupings of related items.  These are all nameable lists and may
appear at the outer level of the source documents.

_feature_::: General-purpose grouping of geometric features, routes, and other
features.  May have any of the _style_, _attestation_, or _popup_ attributes.

_layer_::: Declares a layer, which is a set of map items which can be hidden from or
displayed on the map by means a selection box that LeafletJS displays on the map.
Must contain a _menuitem_ attribute and a _features_ list.

_route_::: Connects segments and/or paths into a complete route.  Contains an ordered
set of _segment_, _path_, and/or _segments_ components, each constituent path of which
must share an endpoint with the neighboring path at the respective end.  May contain
_style_, _attestation_, or _popup_ attributes.

_segment_::: Connects paths into a complete segment.  As with routes, the paths
within a segment must be connected by common endpoints.  May contain _style_,
_attestation_, or _popup_ attributes.

geometric features:: Items with locations specified by latitude and longitude.  These
are all nameable lists and may appear at the outer level of source documents.  All
except _point_ may contain _style_, _attestation_, or _popup_ attributes.

_circle_::: Draws a circle on the map.  Requires a latitude/longitude pair for the
center of the circle and a _radius_ or _pixels_ attribute to declare the circle's
radius.  The _radius_ list sets the radius in meters whereas the _pixels_ list sets
the radius in pixels.

_marker_::: Marker displayed on the map.  Must include a single
latitude/longitude point for the base of the marker.  Uses the normal LeafletJS
marker-icon mechanism unless the _marker_ list contains the _html_ attribute, in
which case the HTML is used in a LeafletJS _divIcon_.

_path_::: Declares a path:  an ordered set of latitude/longitude pairs.  Paths may be
joined in sequence via _segment_ and/or _route_ lists.

_point_::: Locates a single point on the map.  Requires a latitude/longitude pair.
Does not allow any attributes to be set.

_polygon_::: Draws a polygon.  Requires a list of latitude/longitude pairs to mark out
the path that serves as the edges of the polygon.

_rectangle_::: Draws a rectangle on the map.  Requires a latitude/longitude pair
for two opposite corners of the rectange.

attributes:: Modifiers for the above two list categories

_attestation_::: Contains a list of one or more identifiers which summarize how
well attested the feature is that contains the attestation list.  Attestations
for an item modify the item's displayed style in a way configured by
_attestationType_ configuration elements.  Attestation keywords exist in their
own namespace.

_html_::: HTML text to display as a marker rather than a marker icon.  May appear
only in _marker_ lists.  Text must be given as one more more string tokens.

_menuitem_::: Text that describes a layer in Leaflet's selection box.  Must occur
exactly once in a _layer_ list but is prohibited everwhere else.  Text must be given
as a string token.

_pixels_::: Numeric value states the desired _circle_ radius as a number of pixels.

_popup_::: Text to display in a popup box if the user clicks on the map item
containing the _popup_ attribute.  Text must be given as one or more string
tokens.

_radius_::: Numeric value states the desired _circle_ radius as a number of meters.

_style_::: Contains an identifier naming the LeafletJS style to apply to the
other contents of the containing list.  Style names are declared in _baseStyle_
configuration elements and exist in a namespace used only for style names.

configuration:: Configuration of styles and attestation indicators

_config_::: List of configuration items.  If specified for the source data set, the
_config_ list must occur at the outer level of a source file.  It may contain only
_baseStyle_ and _attestationType_ lists.  If not specified, the source data set
must not contain any _style_ or _attestation_ lists.

_baseStyle_::: Declares a base style that may be referenced in a _style_ list in the
main part of the data set.  Contains a list of strings which each set a basic
LeafletJS style property for the named style.  May appear only within a _config_ list.

_attestationType_::: Declares a category of attestation keywords, the rule for
interpreting the keywords, and the enumeration of the attribute keywords themselves
with the related style modifications.  May appear only within a _config_ list.

_attSym_::: Declares an attestation keyword and—depending on the rule for the
attestation type—either the weight to assign to the keyword or the style modification
to apply if the keyword is present.  May appear only within an _attestationType_
list.

_modStyle_::: Declares a set of LeafletJS style properties to override in the base
style for the item being display.  May appear only within _attestationType_ or _attSym_
lists.

lists of references:: Lists which hold references to child items to be contained in
collections

_features_::: Collection of references to _feature_, _route_, and geometric-feature
lists.

_paths_::: Ordered collection of references to _path_ lists.  May occur only within
_segment_ lists.

_segments_::: Ordered collection of segments and/or paths.  May occur only with
_route_ lists.


== Dataset organization

The data in a _misiones_ data set is arranged as a tree, specifically as a _directed
acyclic graph_ (_DAG_).  At the root of the tree is a list of _layer_ lists, each of
which contains one or more features to draw onto the map.  A layer represents a group
of map features which may be hidden or redisplayed by use of a selector displayed on
the map page.  This is an example of the root of a dataset:

----
(layers
    (layer towns
        (menuitem "Towns")
        (feature Metropolis Smallville Middleburg)
    )
    (layer roads
        (menuitem "Roads connecting towns")
        (feature route1 riverRoad)
    )
)
----

Note that the features included in each layer are defined elsewhere in the dataset.
The dataset as a whole may be split among multiple source files.  It is likely
advantageous to place major features in their own source files and indeed to place
the dataset root (the _layers_ list) into a source file by itself.

Note regarding nameable objects:  all such objects have names; if the source text
leaves such an object unnamed, _misiones_ assigns it an internal name consisting of
a dollar sign followed by digits.  Since identfiers in the source files must begin
with a letter or underscore, the sources may not have explicit references to these
internal names.  These names may appear in error messages.

[[Features]]
=== Features

The primary meaning of the word "feature" in relation to maps is a place with a
distinguised characteristic: it is a "point of interest."  Such a place is never a
single point; it has an extent in space.  Oftentimes such a "point of interest" is
composed of multiple smaller points of interest.  This gives rise to the generality
that a feature is a collection of other features, all of which must ultimately refer
to some physical place in order to be presented on the map.

In _misiones_ a _feature_ list expresses such an abstraction.  The list may contain
elementary spatial features such as markers, paths and, polygons or it may, without
restriction, contain collections of features: _route_, _segment_, and indeed, other
_feature_ objects.
Child features may also be included by reference using a _features_ list.

----
(feature MacArthurPark
    (style parkStyle)

    (popup "Mac Arthur Park")
    (polygon
         (style perimeter)
         34.06080 -118.27827  34.05945 -118.27475
         34.05817 -118.28016  34.05657 -118.27668
    )

    (marker
        (popup "The cake in the rain")
        34.05799 -118.27647
    )

    (features mpJoggingTrail)
)
----

A useful capability of _feature_ objects is that child objects inherit any style
and/or attestation applied to the feature object as a whole.  This styling is
applied dynamically when the Javascript application inserts the feature into the
displayed map.  In the above example, the _mpJoggingTrail_ item (whatever its type)
will be drawn as part of the current feature with the prevailing style, _parkStyle_.
If some other feature also uses _mpJoggingTrail_, that instance will expand to that
local style without any reference to its expansion as part of _MacArthurPark_.

The ordering of items within a _feature_ list is insignificant.  Any _style_ or
_attestation_ that is a direct child of _feature_ is applied to the all the elements
of that feature.

[[Segments]]
=== Segments

The _segment_ is a collection type restricted to containing paths and references to
paths.  A _path_ is an ordered set of points and a _segment_ is an ordered set of
paths.  The length of a _path_ can be measured, as can the length of a _segment_.  To
make such measurements possible, two rules apply:

. The paths in a segment must be listed in order of travel from one end of the segment
to the other.

. Each path within a segment must share an endpoint with the adjacent path(s) in the
list of paths for the segment.

The choice of the direction of travel is unimportant both for the segment as a whole
and for the traversal of points within an individual path.

In the following example, note that _secondPath_ continues from the point where
_firstPath_ left off--thus the paths share an endpoint and, in this case, the
points are in the same direction of travel (i.e. east to west).

----
(segment hereIsPart
    (path firstPath
        30.125 -83.143
        30.132 -83.167
        30.139 -83.162
    )
    (path secondPath
        30.139 -83.162
        30.147 -83.153
        30.155 -83.150
    )
)
----

The above segment would remain valid if the points of either or both of the paths
were written in the reverse of the order shown.  The controlling factor is that they
share the endpoint [30.139 -83.162].  The two unmatched exterior endpoints are taken
to be the endpoints of the segment as a whole.  The segment would likewise remains
valid if its two paths were listed in the opposite order.

The only time where the lexical ordering of paths (viz. the order of paths as
specified in the source file) comes into play is when using the `--upto` option of
the `-m` (measurement) function.  This calculates which point along a route, segment,
or path is at a given distance from the starting point.

Segments may also contain references to paths defined elsewhere in the data set.
The above example could be rewritten as

----
(segment hereIsPart
    (path firstPath
        30.125 -83.143
        30.132 -83.167
        30.139 -83.162
    )
    (paths secondPath)
)

(path secondPath
    30.139 -83.162
    30.147 -83.153
    30.155 -83.150
)
----

A _segment_ may contain zero or one of each of _popup_, _style_, and _attestation_.
As with other container types, these attributes apply to all the path elements
contained in or referenced by the segment.  Individual paths may also be marked with
these attributes, a fact which may be used to simplify the design of a dataset.

It is possible for the dataset to contain a path referenced by more than segment.
It is quite likely in such a case that the two referring segments differ in style and
attestation patterns.  A strategy to avoid the wasteful duplication of the path
definition is to assign to paths only those attestations which pertain to how the
path appears in the modern terrain while the styles reflect only the historical
attestations.

The ElDestino dataset uses this pattern.  It defines a set of weighted attestation
markers related to historical references (e.g. "scholarly" and "old_map") and
markers related to how well attested the feature is in the modern terrain (e.g.
"modern_name" and "guess").  Since paths are drawn in the modern environment, the
latter attestation markers apply to them.  Segments carry the historal-attestation
markers.

----
(segment crosspointWay
    (attestation old_map scholarly)
    (paths missionRoad_CR1568 patalePath)
)

(path missionRoad_CR1568
    (attestation modernName)
    30.46343 -84.15002
    30.46717 -84.14993
)

(path patalePath
    (attestation guess)
    30.46717 -84.14993
    30.46736 -84.15019
)
----

[[Routes]]
=== Routes

A route is an ordered collection of segments and/or paths.  As with segments, the
components of a _route_ must be listed in order of travel of the components and
each of these components must be linked by common endpoints.  Also in common with
segments and paths, the choice of starting and ending points when listing a route's
components makes no difference except for users measuring partial distances along a
route.

The separate _route_ type makes it possible to apply styling to the route as a whole
without repeating the styling for each segment.  This also allows for the sharing of
segments across separate routes.

=== Geometric features

The set of geometric features in _misiones_ all correspond to the similarly named
object types in LeafletJS.  As is true of other nameable objects in _misiones_,
geometric features (with the exception of _point_) may have _popup_, _style_, and
_attestation_ attributes.

All geometric features declare at least one latitude/longitude pair, which is a pair
of floating-point values in units of degrees.  Operations in _misiones_ which compare
points for equality measure the difference in each axis within 5×10^-7^ degrees.
This gives an error about about half a meter of latitude and 3/4 of a meter in
longitude at 30° latitude.

[options="header",cols="<,^,<"]
|====
|Type | Number of pairs | Usage
|_point_     | 1   | coordinates of point
|_marker_    | 1   | coordinates of base of marker
|_circle_    | 1   | center of circle
|_rectangle_ | 4   | corners of the rectangle
|_polygon_   | > 1 | nodes along the perimeter of the polygon
|_path_      | > 1 | nodes along the path
|====

